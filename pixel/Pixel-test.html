<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Pixel Drawing</title>
<link rel="stylesheet" href="https://unpkg.com/98.css" />
<style>
  body {
    background: #008080;
    font-family: "MS Gothic", monospace;
    user-select: none;
    margin: 0;
    display: flex;
    justify-content: center;
    padding: 20px;
    box-sizing: border-box;
  }
  main.window {
    background: #c0c0c0;
    border: 2px solid #000;
    box-shadow: inset 1px 1px 0 #fff, inset -1px -1px 0 #404040;
    padding: 16px;
    width: 100%;
    max-width: 960px;
    display: flex;
    flex-direction: column;
    gap: 1rem;
  }
  h1 {
    font-weight: normal;
    color: #000080;
    text-shadow: 1px 1px 0 #fff;
    margin: 0 auto 1rem;
  }
  #titleContainer {
    display: flex;
    align-items: center;
    gap: 8px;
    flex-wrap: wrap;
    justify-content: center;
  }
  #title-label {
    font-weight: bold;
    color: #000080;
    text-shadow: 1px 1px #fff;
    user-select: none;
  }
  #titleInput {
    font-family: "MS Gothic", monospace;
    font-size: 1rem;
    border: 2px inset buttonface;
    padding: 4px 8px;
    min-width: 180px;
    max-width: 100%;
    box-sizing: border-box;
  }
  #app-container {
    display: flex;
    flex-wrap: wrap;
    gap: 1rem;
    justify-content: center;
  }
  #palette {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(36px, 1fr));
    grid-gap: 6px;
    border: 2px outset buttonface;
    padding: 8px;
    background: #c0c0c0;
    min-width: 140px;
    max-width: 100%;
  }
  .color-btn {
    width: 36px;
    height: 36px;
    cursor: pointer;
    border: 2px outset buttonface;
    box-sizing: border-box;
    background-clip: padding-box;
    border-radius: 0;
  }
  .color-btn.selected {
    border-style: inset;
    outline: 2px solid #000080;
    outline-offset: 1px;
  }
  .color-btn.transparent {
    background:
      repeating-linear-gradient(
        45deg,
        #ccc,
        #ccc 4px,
        #fff 4px,
        #fff 8px
      );
    position: relative;
  }
  .color-btn.transparent::after {
    content: "T";
    position: absolute;
    top: 8px;
    left: 12px;
    font-weight: bold;
    color: black;
    user-select: none;
  }
  #canvas {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(24px, 1fr));
    grid-gap: 2px;
    border: 2px outset buttonface;
    background-color: #c0c0c0;
    max-width: 100%;
    aspect-ratio: 1 / 1;
    touch-action: none;
  }
  .pixel {
    width: 24px;
    height: 24px;
    background-color: transparent;
    border: 2px inset buttonface;
    cursor: pointer;
    box-sizing: border-box;
    transition: background-color 0.15s ease;
  }
  .pixel:hover {
    filter: brightness(0.85);
  }
  #controls {
    margin-top: 1rem;
    text-align: center;
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    justify-content: center;
  }
  #controls button {
    margin: 0;
    padding: 6px 16px;
    font-family: "MS Gothic", monospace;
    font-size: 1rem;
    border: 2px outset buttonface;
    cursor: pointer;
    user-select: none;
    min-width: 120px;
    flex-grow: 1;
    max-width: 200px;
  }
  #controls button:active {
    border-style: inset;
    background: #c0c0c0;
  }
  #controls button:focus-visible {
    outline: 2px solid #000080;
    outline-offset: 2px;
  }
  @media (max-width: 480px) {
    #palette {
      grid-template-columns: repeat(auto-fit, minmax(28px, 1fr));
      min-width: 100px;
    }
    .color-btn {
      width: 28px;
      height: 28px;
    }
    #canvas {
      grid-template-columns: repeat(16, 20px);
      grid-gap: 1px;
    }
    .pixel {
      width: 20px;
      height: 20px;
      border-width: 1px;
    }
  }
</style>
</head>
<body>
<main class="window" role="main" aria-label="ピクセルお絵かきアプリ">
  <h1>Pixel Drawing</h1>
  <div id="titleContainer">
    <label id="title-label" for="titleInput">作品名（任意）:</label>
    <input type="text" id="titleInput" placeholder="作品名を入力してください" autocomplete="off" />
  </div>
  <section id="app-container" aria-label="描画エリアとパレット">
    <nav id="palette" role="list" aria-label="色パレット"></nav>
    <div id="canvas" role="grid" aria-label="ピクセル描画キャンバス" tabindex="0"></div>
  </section>
  <section id="controls" aria-label="操作ボタン">
    <button id="btn-reset" type="button">ボードをリセット</button>
    <button id="btn-save" type="button">JSONで保存</button>
    <button id="btn-load" type="button">JSON読み込み</button>
    <button id="btn-img-save" type="button">画像保存</button>
    <input type="file" id="file-load" accept=".json" style="display:none" />
  </section>
</main>

<script>
 (() => {
  const SUPPORTED_VERSIONS = ["1.0", "2.0"];

  const APP_NAME = "PixelDraw";
  const APP_VERSION = "2.0";

  const WIDTH = 16;
  const HEIGHT = 16;

  const palette = [
    "#000000",    // 黒 (C0%, M0%, Y0%, K100%)
    "#ff0000",
    "#00ff00",
    "#0000ff",
    "#ffff00",
    "#ffffff",
    "#00000000"   // 透明
  ];

  let currentColor = palette[0];
  let isDrawing = false;

  const paletteEl = document.getElementById("palette");
  const canvasEl = document.getElementById("canvas");
  const resetBtn = document.getElementById("btn-reset");
  const saveBtn = document.getElementById("btn-save");
  const loadBtn = document.getElementById("btn-load");
  const fileLoadInput = document.getElementById("file-load");
  const titleInput = document.getElementById("titleInput");

  for (let i = 0; i < WIDTH * HEIGHT; i++) {
    const pixel = document.createElement("div");
    pixel.classList.add("pixel");
    pixel.dataset.index = i;
    pixel.style.backgroundColor = palette[6]; // 透明初期化
    canvasEl.appendChild(pixel);
  }

  function createPalette() {
    paletteEl.innerHTML = "";
    palette.forEach((c) => {
      const btn = document.createElement("div");
      btn.className = "color-btn";
      btn.style.backgroundColor = c;
      if (c === "#00000000") {
        btn.classList.add("transparent");
        btn.title = "透明";
      } else {
        btn.title = `色: ${c}`;
      }
      btn.addEventListener("click", () => selectColor(c, btn));
      paletteEl.appendChild(btn);
      if (c === currentColor) btn.classList.add("selected");
    });
  }

  function selectColor(color, btnEl) {
    currentColor = color;
    paletteEl.querySelectorAll(".color-btn").forEach((b) =>
      b.classList.remove("selected")
    );
    btnEl.classList.add("selected");
  }

  function paintPixel(pixel) {
    pixel.style.backgroundColor = currentColor;
  }

  function onDrawChange() {
    saveToLocalStorage();
  }

  canvasEl.addEventListener("mousedown", (e) => {
    if (!e.target.classList.contains("pixel")) return;
    isDrawing = true;
    paintPixel(e.target);
    onDrawChange();
  });
  canvasEl.addEventListener("mouseover", (e) => {
    if (isDrawing && e.target.classList.contains("pixel")) {
      paintPixel(e.target);
      onDrawChange();
    }
  });
  window.addEventListener("mouseup", () => {
    isDrawing = false;
  });

  resetBtn.addEventListener("click", () => {
    if (confirm("本当にボードをリセットして全てクリアしますか？")) {
      canvasEl.querySelectorAll(".pixel").forEach((p) => (p.style.backgroundColor = palette[6]));
      localStorage.removeItem("pixelDrawingData-2");
      titleInput.value = "";
    }
  });

  saveBtn.addEventListener("click", () => {
    downloadJson();
  });

  loadBtn.addEventListener("click", () => {
    fileLoadInput.value = null;
    fileLoadInput.click();
  });

  fileLoadInput.addEventListener("change", (e) => {
    const file = e.target.files[0];
    if (!file) return alert("ファイルが選択されていません。");
    if (!file.name.endsWith(".json")) return alert("JSONファイルを選択してください。");
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (
          data.app !== APP_NAME ||
          !SUPPORTED_VERSIONS.includes(data.version) ||
          data.width !== WIDTH ||
          data.height !== HEIGHT ||
          !Array.isArray(data.pixels)
        ) {
          return alert("JSONデータの形式が不正です。");
        }
        titleInput.value = data.title || "";
        loadPixels(data);
        alert("作品を読み込みました。");
        saveToLocalStorage();
      } catch {
        alert("JSONファイルの読み込みに失敗しました。");
      }
    };
    reader.readAsText(file);
  });

  window.addEventListener("load", () => {
    const saved = localStorage.getItem("pixelDrawingData-2");
    if (saved) {
      try {
        const data = JSON.parse(saved);
        if (
          data.app === APP_NAME &&
          SUPPORTED_VERSIONS.includes(data.version) &&
          data.width === WIDTH &&
          data.height === HEIGHT &&
          Array.isArray(data.pixels)
        ) {
          titleInput.value = data.title || "";
          loadPixels(data);
        }
      } catch {}
    }
  });

  titleInput.addEventListener("input", () => saveToLocalStorage());

  function loadPixels(data) {
    canvasEl.querySelectorAll(".pixel").forEach(
      (p) => (p.style.backgroundColor = palette[6])
    ); // 透明クリア

    if (data.version === "1.0") {
      // v1.0 はpixelsに {x,y,color}形式
      data.pixels.forEach(({ x, y, color }) => {
        if (
          x >= 0 &&
          x < WIDTH &&
          y >= 0 &&
          y < HEIGHT &&
          typeof color === "string"
        ) {
          const idx = y * WIDTH + x;
          const pixel = canvasEl.querySelector(`.pixel[data-index="${idx}"]`);
          if (pixel) pixel.style.backgroundColor = color;
        }
      });
    } else if (data.version === "2.0") {
      // v2.0は圧縮配列 [startX,length],colorIndex 形式も混在
      let i = 0,
        x = 0,
        y = 0;
      while (i < data.pixels.length) {
        const elem = data.pixels[i];
        if (Array.isArray(elem)) {
          const startX = elem[0];
          const length = elem[1];
          const colorIndex = data.pixels[i + 1];
          for (let lx = 0; lx < length; lx++) {
            const idx = y * WIDTH + startX + lx;
            const pixel = canvasEl.querySelector(`.pixel[data-index="${idx}"]`);
            if (pixel) pixel.style.backgroundColor = palette[colorIndex];
          }
          i += 2;
          x = startX + length;
        } else {
          const colorIndex = elem;
          const idx = y * WIDTH + x;
          const pixel = canvasEl.querySelector(`.pixel[data-index="${idx}"]`);
          if (pixel) pixel.style.backgroundColor = palette[colorIndex];
          x++;
          i++;
        }
        if (x >= WIDTH) {
          y++;
          x = 0;
        }
      }
    }
  }

  function saveToLocalStorage() {
    const pixels = canvasEl.querySelectorAll(".pixel");
    let pixelsData = [];

    for (let y = 0; y < HEIGHT; y++) {
      let x = 0;
      while (x < WIDTH) {
        const idx = y * WIDTH + x;
        const pixel = pixels[idx];
        let color = palette.indexOf(pixel.style.backgroundColor);
        if (color < 0) color = 6; // 透明

        let length = 1;
        while (x + length < WIDTH) {
          const nextIdx = y * WIDTH + x + length;
          const nextPixel = pixels[nextIdx];
          const nextColor = palette.indexOf(nextPixel.style.backgroundColor);
          if (nextColor !== color) break;
          length++;
        }

        if (length >= 3) {
          pixelsData.push([x, length], color);
          x += length;
        } else {
          for (let i = 0; i < length; i++) pixelsData.push(color);
          x += length;
        }
      }
    }

    const data = {
      app: APP_NAME,
      version: APP_VERSION,
      width: WIDTH,
      height: HEIGHT,
      title: titleInput.value.trim() || undefined,
      palette: palette,
      pixels: pixelsData,
    };
    localStorage.setItem("pixelDrawingData-2", JSON.stringify(data));
  }

  function downloadJson() {
    const pixels = canvasEl.querySelectorAll(".pixel");
    let pixelsData = [];

    for (let y = 0; y < HEIGHT; y++) {
      let x = 0;
      while (x < WIDTH) {
        const idx = y * WIDTH + x;
        const pixel = pixels[idx];
        let color = palette.indexOf(pixel.style.backgroundColor);
        if (color < 0) color = 6; // 透明

        let length = 1;
        while (x + length < WIDTH) {
          const nextIdx = y * WIDTH + x + length;
          const nextPixel = pixels[nextIdx];
          const nextColor = palette.indexOf(nextPixel.style.backgroundColor);
          if (nextColor !== color) break;
          length++;
        }

        if (length >= 3) {
          pixelsData.push([x, length], color);
          x += length;
        } else {
          for (let i = 0; i < length; i++) pixelsData.push(color);
          x += length;
        }
      }
    }

    const data = {
      app: APP_NAME,
      version: APP_VERSION,
      width: WIDTH,
      height: HEIGHT,
      title: titleInput.value.trim() || undefined,
      palette: palette,
      pixels: pixelsData,
    };

    const jsonStr = JSON.stringify(data, null, 2);
    const blob = new Blob([jsonStr], { type: "application/json" });
    const dt = new Date();
    const pad = (n) => n.toString().padStart(2, "0");
    const filename = `${APP_NAME}-${APP_VERSION}_${dt.getFullYear()}-${pad(
      dt.getMonth() + 1
    )}-${pad(dt.getDate())}_${pad(dt.getHours())}-${pad(
      dt.getMinutes()
    )}-${pad(dt.getSeconds())}.json`;
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    alert("作品を保存しました。");
  }

  createPalette();
})();
</script>
</body>
</html>
